---
title: "Results_Landquart"
format: html
---

# Packages & Working directory
```{r}
rm(list = ls())

# load all Packages 
library(hdf5r)
library(sp)
library(sf)
library(ggplot2)
library(dplyr)
library(readr)
library(Metrics)
library(raster)
```

# Read results 
```{r}
#read results --------
#path to results file
h5_s1  <- h5file("hydrodynamic_model_results/results_7_calc.h5")


# > h5
# Class: H5File
# Filename: D:\Backup_daten\eDNA\basement\luca\mountain_river\results.h5
# Access type: H5F_ACC_RDWR
# Listing:
#   name  obj_type dataset.dims dataset.type_class
# .config H5I_GROUP         <NA>               <NA>
#   CellsAll H5I_GROUP         <NA>               <NA>
#   NodeStrg H5I_GROUP         <NA>               <NA>
#   NodesAll H5I_GROUP         <NA>               <NA>
#   Parameters H5I_GROUP         <NA>               <NA>
#   RESULTS H5I_GROUP         <NA>               <NA>
```

# access sub-directories
```{r}
#to access the different sub-directories ("groups") use "[[]]"
results_s1 <- h5_s1[["RESULTS"]][["CellsAll"]]
```

# extract velocity & waterdepth 
```{r}
#HydState contains results from the Hydraulic module (water depth, flow velocities), TrcState those from the Tracer Module
#Extracting the resutls from the last timestep (0000005)
# mabsl <- as.data.frame(results[["HydState"]][[formatC(0000024, width = 7, flag = 0)]][1,]) # Meter Ã¼ber Meer
# water_depth <- as.data.frame(results[["HydState"]][[formatC(0000024, width = 7, flag = 0)]][2,]) # Wassertiefe?
# velocity <- as.data.frame(results[["HydState"]][[formatC(0000024, width = 7, flag = 0)]][3,]) # fliessgeschwindigkeit?
#tracer4 <- as.data.frame(results[["HydState"]][[formatC(5, width = 7, flag = 0)]][4,])
#tracer5 <- as.data.frame(results[["HydState"]][[formatC(5, width = 7, flag = 0)]][5,])

# S1
bottomElevation_s1 <- h5_s1[["CellsAll"]][["BottomEl"]][,]
waterSurfElev_s1 <- results_s1[["HydState"]][["0000024"]][1,]
qX_s1 <- results_s1[["HydState"]][["0000024"]][2,]
qY_s1 <- results_s1[["HydState"]][["0000024"]][3,]
depth_s1 <- waterSurfElev_s1 - bottomElevation_s1
vX_s1 <- qX_s1/depth_s1
vY_s1 <- qY_s1/depth_s1
V_abs_s1 <- (vX_s1^2+vY_s1^2)^.5


mabsl_s1 <- waterSurfElev_s1
waterdepth_s1 <- depth_s1
velocity_s1 <- V_abs_s1
```

# Read mesh and create shp
```{r}
#mesh paths
Twodm_path <- "hydrodynamic_model_results/Landquart_computational-mesh_anto_depthcorr.2dm"

#read mesh as a table
Twodm <- read.table(Twodm_path, sep="", skip=2, header=F, fill=T)

#split mesh in nodes and elements
#nodes
nd_df <- Twodm[which(Twodm$V1=="ND"),-1]
colnames(nd_df) <- c( "ID", "X", "Y", "Z")
nd_df$X <- as.numeric(nd_df$X)
nd_df$Y <- as.numeric(nd_df$Y)

#elements
e3t_df <- Twodm[which(Twodm$V1=="E3T"),][,-1]
colnames(e3t_df) <- c( "ID", "N1", "N2", "N3")


#create table with coordinates of each triangular element (x1,y1,x2,y2,x3,y3)
triangles <- (cbind(nd_df[e3t_df$N1, c("X","Y")], nd_df[e3t_df$N2, c("X","Y")], nd_df[e3t_df$N3, c("X","Y")], nd_df[e3t_df$N1, c("X","Y")]))

tr_matrix <- matrix(unlist(triangles), ncol=8, byrow = F)

#number of elements
ID <- e3t_df$ID
length(ID) # 38694 triangular cells in the computational mesh

# Create SP object
polys <- SpatialPolygons(mapply(function(poly, id) {
  xy <- matrix(poly, ncol=2, byrow=TRUE)
  Polygons(list(Polygon(xy)), ID=id)
}, split(tr_matrix, row(tr_matrix)), ID))


# Create SPDF (exportable as shapefile)
mesh.sp <- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))

#link results with mesh
mesh.sp$mabsl_s1 <- as.numeric(round(mabsl_s1,3))
mesh.sp$waterdepth_s1 <- as.numeric(round(waterdepth_s1,3))
mesh.sp$velocity_s1 <- as.numeric(round(velocity_s1,3))

#write new shapefile
# overwrite = TRUE
shapefile(mesh.sp, "hydrodynamic_model_results/Landquart_results.shp", overwrite = TRUE)
```

# GPS Results 
## Set working directory & load data 
```{r}
# read GPS-Points 
gps <- read_sf("hydrodynamic_model_results/GPS_all_align_elevation_mesh.shp")

# convert 3d gps data into 2d data 
gps_2d <- st_zm(gps, drop=TRUE, what = "ZM")

# read simulation results & set coordinate system (2056)
simulations <- read_sf("hydrodynamic_model_results/Landquart_results.shp") |> st_set_crs(2056)
```

## prepare data-set
```{r}
# Only GPS points measured in the field are of interest 
# Extract results at GPS locations with st_join 
gps_join <- gps_2d |>
  st_join(simulations, join=st_within) 

gps_join
# data-set with water-depth & without NA rows 
gps_waterdepth <- gps_join[ ,c(6:7, 11:12)]
gps_waterdepth <- na.omit(gps_waterdepth)


# data-set waterdepth only of field data 
wt_field <-gps_waterdepth[!(gps_waterdepth$code=="w_art" | gps_waterdepth$code=="wl_art"),]
length(wt_field$code)

# data-set with only velocity & without NA rows + only field data
gps_velocity <- gps_join[ ,c(13)]
gps_velocity <- na.omit(gps_velocity)

# change from cm/s into m/s
gps_velocity <- (gps_velocity/100)
length(gps_velocity$velocity_c)
```

## calculate mean, min, max, sd
```{r}
# calculate mean, min, max, std of gps and s1 - for field data 
# for field measurements 
gps_results_v <- gps_join |>
  as.data.frame()|>
  summarise(mean_v_gps = mean((velocity_c/100), na.rm = TRUE),
            min_v_gps = min((velocity_c/100), na.rm = TRUE),
            max_v_gps = max((velocity_c/100), na.rm = TRUE),
            sd_v_gps = sd((velocity_c/100), na.rm = TRUE))
gps_results_v <- rename(gps_results_v, mean_v = mean_v_gps, min_v = min_v_gps, max_v = max_v_gps, sd_v = sd_v_gps)


gps_results_wt <- wt_field |>
  as.data.frame()|>
  summarise(mean_wt_gps = mean(wt_m_dsm, na.rm = TRUE),
            min_wt_gps = min(wt_m_dsm, na.rm = TRUE),
            max_wt_gps = max(wt_m_dsm, na.rm = TRUE),
            sd_wt_gps = sd(wt_m_dsm, na.rm = TRUE))
gps_results_wt <- rename(gps_results_wt, mean_wt = mean_wt_gps, min_wt = min_wt_gps,
                         max_wt = max_wt_gps, sd_wt = sd_wt_gps)


# for simulation S1
gps_results_s1_v <- gps_join |>
  as.data.frame()|>
  summarise(mean_v_s1 = mean(velocity_0, na.rm = TRUE),
            min_v_s1 = min(velocity_0,  na.rm = TRUE),
            max_v_s1 = max(velocity_0,  na.rm = TRUE),
            sd_v_s1 = sd(velocity_0,  na.rm = TRUE))
gps_results_s1_v <- rename(gps_results_s1_v, mean_v = mean_v_s1, min_v = min_v_s1, max_v = max_v_s1, sd_v = sd_v_s1)

gps_results_s1_wt <- wt_field |>
  as.data.frame()|>
  summarise(mean_wt_s1 = mean(waterdept0, na.rm = TRUE),
            min_wt_s1 = min(waterdept0,  na.rm = TRUE),
            max_wt_s1 = max(waterdept0,  na.rm = TRUE),
            sd_wt_s1 = sd(waterdept0,  na.rm = TRUE))
gps_results_s1_wt <- rename(gps_results_s1_wt, mean_wt = mean_wt_s1, min_wt = min_wt_s1, max_wt = max_wt_s1, sd_wt = sd_wt_s1)
```

## write data.frame of results 
```{r}
# Results Velocity
gps_results_v <- rbind(gps_results_v, gps_results_s1_v)
gps_results_v$run <- c("real/gps", "s1")
gps_results_v


# RESULTS water depth 
gps_results_wt <- rbind(gps_results_wt, gps_results_s1_wt)
gps_results_wt$run <- c("real/gps", "s1")
gps_results_wt

# join datarame results 
gps_results <- full_join(gps_results_v, gps_results_wt, by = "run") |>
  relocate(run, .before = mean_v)
```

## calculate rmse and mae 
```{r}
# RMSE S1 waterdepth & velocity
rmse_wt_s1 <- rmse(gps_waterdepth$wt_m_dsm, gps_waterdepth$waterdept0)
rmse_v_s1 <- rmse(gps_velocity$velocity_c, gps_velocity$velocity_0)

# MAE S1 waterdepth & velocity
mae_wt_s1 <- mae(gps_waterdepth$wt_m_dsm, gps_waterdepth$waterdept0)
mae_v_s1 <- mae(gps_velocity$velocity_c, gps_velocity$velocity_0)
```

## write data.frame of results & join all results together
```{r}
# create df of results RMSE & MAE
RMSE_MAE <- data.frame(rmse_wt = c(rmse_wt_s1),
                       mae_wt = c(mae_wt_s1),
                   rmse_v = c(rmse_v_s1),
                   mae_v = c(mae_v_s1),
                   run = c("s1"))

# join results of mean, min, max, sd with RMSE_MAE results
results_all <- full_join(RMSE_MAE, gps_results, by = "run") |>
  relocate(run, .before = rmse_wt)

# export dataframe to .csv
write.csv(results_all, "results_r.csv", row.names=FALSE)
```

## calculate MAE for dsm_wse with measured wse and visualise results
```{r}
# set working directory 
setwd("C:/Users/mirja/Documents/MSc_ENR_Studium/1._Semester_HS22/Project_Work_Research_Group_1/Excel")

# read csv. file 
wse <- read_delim("L2_r2_corr.csv")

# prepare data set, remove rows with NA 
wse <- wse[ ,c(1:5,8:9)]
wse <- na.omit(wse)

# drop outliers in DSM, which reflect vegetation height (e.g. trees etc.)
wse_smooth <-wse[!(wse$dsm_wse > 798), ]

# calculate MAE & RMSE
mae(wse_smooth$mabsl_wse, wse_smooth$dsm_wse)
rmse(wse_smooth$mabsl_wse, wse_smooth$dsm_wse)

# calculate mean of DSM and field GPS
mean(wse_smooth$mabsl_wse)
mean(wse_smooth$dsm_wse)

# join tables with information from the field and all simulations
wse_join <- wse_smooth |>
left_join(gps_join, by = "x")
```


